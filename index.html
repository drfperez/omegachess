<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Omega Chess: Pro AI</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-dark: #7f8c8d;
            --board-light: #ecf0f1;
            --highlight: rgba(241, 196, 15, 0.6);
            --hint: rgba(46, 204, 113, 0.7);
            --last-move: rgba(52, 152, 219, 0.6);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        h1 { margin: 5px 0; font-size: 1.2rem; }
        
        #status {
            margin-bottom: 8px;
            font-weight: bold;
            color: #f39c12;
            height: 20px;
            font-size: 1rem;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            width: 92vmin;
            height: 92vmin;
            max-width: 550px;
            max-height: 550px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #34495e;
        }

        .square {
            position: relative;
            display: grid; 
            place-items: center; 
            font-size: 3.5vmin;
            cursor: pointer;
        }
        
        @media (min-width: 550px) { .square { font-size: 26px; } }

        .square.light { background-color: var(--board-light); }
        .square.dark { background-color: var(--board-dark); }
        .square.wizard-square {
            background-color: #95a5a6;
            border: 1px solid #34495e;
            box-sizing: border-box;
        }
        .square.void { visibility: hidden; pointer-events: none; }
        .square.selected { background-color: var(--highlight) !important; }
        .square.last-move { background-color: var(--last-move) !important; }

        .hint-dot {
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: var(--hint);
            border-radius: 50%;
            z-index: 5;
        }

        .piece {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; line-height: 1; z-index: 2;
            transform: translateY(-8%); font-size: 160%; 
        }
        
        .white-piece { color: #fff; text-shadow: 0px 2px 2px rgba(0,0,0,0.6); }
        .black-piece { color: #1a1a1a; text-shadow: 0px 0px 2px rgba(255,255,255,0.4); }

        #controls { 
            margin-top: 12px; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 8px; 
            justify-content: center; 
            width: 90%;
        }

        button, select {
            padding: 8px 12px;
            background: #34495e;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            outline: none;
        }

        button.primary { background: #e74c3c; font-weight: bold; }
        button:active { opacity: 0.8; }
        
        .difficulty-container {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.2);
            padding: 4px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <h1>Omega Chess</h1>
    <div id="status">White to Move</div>
    <div id="board"></div>

    <div id="controls">
        <div class="difficulty-container">
            <span>AI:</span>
            <select id="difficulty">
                <option value="1">Easy</option>
                <option value="2" selected>Medium</option>
                <option value="3">Hard</option>
            </select>
        </div>
        <button onclick="undoMoveUI()">Undo Move</button>
        <button class="primary" onclick="resetGame()">New Game</button>
    </div>

<script>
const SIZE = 12;
const PIECES = { EMPTY: 0, PAWN: 1, ROOK: 2, KNIGHT: 3, BISHOP: 4, QUEEN: 5, KING: 6, CHAMPION: 7, WIZARD: 8 };
const COLORS = { WHITE: 0, BLACK: 1 };
const SYMBOLS = {
    [PIECES.PAWN]: '♟', [PIECES.ROOK]: '♜', [PIECES.KNIGHT]: '♞', 
    [PIECES.BISHOP]: '♝', [PIECES.QUEEN]: '♛', [PIECES.KING]: '♚',
    [PIECES.CHAMPION]: '☖', [PIECES.WIZARD]: '☾' 
};

const PIECE_VALUES = {
    [PIECES.PAWN]: 100, [PIECES.KNIGHT]: 320, [PIECES.BISHOP]: 330, 
    [PIECES.WIZARD]: 350, [PIECES.CHAMPION]: 450, [PIECES.ROOK]: 500, 
    [PIECES.QUEEN]: 900, [PIECES.KING]: 20000
};

const CENTER_BONUS = Array(12).fill(0).map((_, r) => 
    Array(12).fill(0).map((_, c) => {
        const dist = Math.abs(5.5 - r) + Math.abs(5.5 - c);
        return Math.floor(25 - dist * 2);
    })
);

let board = [];
let turn = COLORS.WHITE;
let selectedSq = null;
let possibleMoves = [];
let lastMove = null;
let castlingRights = { wK: true, wQ: true, bK: true, bQ: true };
let enPassantTarget = null;
let kingPos = { [COLORS.WHITE]: null, [COLORS.BLACK]: null };
let gameOver = false;
let undoStack = [];

function initBoard() {
    board = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));
    const layout = [PIECES.CHAMPION, PIECES.ROOK, PIECES.KNIGHT, PIECES.BISHOP, PIECES.QUEEN, 
                    PIECES.KING, PIECES.BISHOP, PIECES.KNIGHT, PIECES.ROOK, PIECES.CHAMPION];

    for (let c = 1; c <= 10; c++) {
        board[1][c] = { type: layout[c-1], color: COLORS.BLACK, hasMoved: false };
        board[2][c] = { type: PIECES.PAWN, color: COLORS.BLACK, hasMoved: false };
        board[10][c] = { type: layout[c-1], color: COLORS.WHITE, hasMoved: false };
        board[9][c] = { type: PIECES.PAWN, color: COLORS.WHITE, hasMoved: false };
    }
    [[0,0], [0,11]].forEach(([r,c]) => board[r][c] = { type: PIECES.WIZARD, color: COLORS.BLACK, hasMoved: false });
    [[11,0], [11,11]].forEach(([r,c]) => board[r][c] = { type: PIECES.WIZARD, color: COLORS.WHITE, hasMoved: false });
    kingPos[COLORS.BLACK] = { r: 1, c: 6 };
    kingPos[COLORS.WHITE] = { r: 10, c: 6 };
    castlingRights = { wK: true, wQ: true, bK: true, bQ: true };
    enPassantTarget = null; turn = COLORS.WHITE; gameOver = false; lastMove = null; undoStack = [];
    updateStatus("White to Move");
    renderBoard();
}

function isValidSquare(r, c) {
    if ((r===0 || r===11) && (c===0 || c===11)) return true;
    return (r >= 1 && r <= 10 && c >= 1 && c <= 10);
}

function getMoves(r, c, checkCheck = true) {
    const p = board[r][c];
    if (!p) return [];
    let moves = [];
    const color = p.color;
    const forward = color === COLORS.WHITE ? -1 : 1;
    const add = (tr, tc) => {
        if (!isValidSquare(tr, tc)) return;
        const target = board[tr][tc];
        if (!target || target.color !== color) moves.push({ r: tr, c: tc });
    };
    const slide = (dr, dc) => {
        let cr = r + dr, cc = c + dc;
        while (isValidSquare(cr, cc)) {
            const target = board[cr][cc];
            if (!target) { moves.push({ r: cr, c: cc }); } 
            else { if (target.color !== color) moves.push({ r: cr, c: cc }); break; }
            cr += dr; cc += dc;
        }
    };

    if (p.type === PIECES.PAWN) {
        if (isValidSquare(r+forward, c) && !board[r+forward][c]) {
            moves.push({ r: r+forward, c: c });
            if (!p.hasMoved) {
                if (isValidSquare(r+forward*2, c) && !board[r+forward*2][c]) {
                    moves.push({ r: r+forward*2, c: c, isDouble: true });
                    if (isValidSquare(r+forward*3, c) && !board[r+forward*3][c]) {
                        moves.push({ r: r+forward*3, c: c, isTriple: true });
                    }
                }
            }
        }
        [[forward, -1], [forward, 1]].forEach(([dr, dc]) => {
            const tr = r+dr, tc = c+dc;
            if (isValidSquare(tr, tc)) {
                const target = board[tr][tc];
                if (target && target.color !== color) moves.push({ r: tr, c: tc });
                if (!target && enPassantTarget && enPassantTarget.r === tr && enPassantTarget.c === tc) {
                    moves.push({ r: tr, c: tc, isEnPassant: true });
                }
            }
        });
    } else if (p.type === PIECES.KNIGHT) {
        [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(([dr,dc])=>add(r+dr, c+dc));
    } else if (p.type === PIECES.BISHOP) {
        [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>slide(dr,dc));
    } else if (p.type === PIECES.ROOK) {
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc])=>slide(dr,dc));
    } else if (p.type === PIECES.QUEEN) {
        [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>slide(dr,dc));
    } else if (p.type === PIECES.CHAMPION) {
        [[2,0],[-2,0],[0,2],[0,-2],[2,2],[2,-2],[-2,2],[-2,-2],[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>add(r+dr, c+dc));
    } else if (p.type === PIECES.WIZARD) {
        [[1,3],[1,-3],[-1,3],[-1,-3],[3,1],[3,-1],[-3,1],[-3,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>add(r+dr, c+dc));
    } else if (p.type === PIECES.KING) {
        [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>add(r+dr, c+dc));
        if (!p.hasMoved && checkCheck && !isSquareAttacked(r, c, 1-color)) {
            const ks = color === COLORS.WHITE ? castlingRights.wK : castlingRights.bK;
            const qs = color === COLORS.WHITE ? castlingRights.wQ : castlingRights.bQ;
            if (ks && !board[r][c+1] && !board[r][c+2] && !isSquareAttacked(r, c+1, 1-color) && !isSquareAttacked(r, c+2, 1-color)) moves.push({ r: r, c: c+2, castle: 'K' });
            if (qs && !board[r][c-1] && !board[r][c-2] && !board[r][c-3] && !isSquareAttacked(r, c-1, 1-color) && !isSquareAttacked(r, c-2, 1-color)) moves.push({ r: r, c: c-2, castle: 'Q' });
        }
    }
    if (checkCheck) return moves.filter(m => {
        const u = makeMoveInternal(r, c, m, false);
        const ic = isInCheck(color);
        undoMoveInternal(u);
        return !ic;
    });
    return moves;
}

function isSquareAttacked(r, c, attCol) {
    for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE; j++) {
            const p = board[i][j];
            if (p && p.color === attCol) {
                const moves = getMoves(i, j, false);
                if (moves.some(m => m.r === r && m.c === c)) return true;
            }
        }
    }
    return false;
}

function isInCheck(col) {
    const k = kingPos[col];
    return isSquareAttacked(k.r, k.c, 1-col);
}

function makeMoveInternal(fr, fc, m, pushToStack = true) {
    const p = board[fr][fc];
    const undo = {
        fr, fc, tr: m.r, tc: m.c, movedPiece: p, captured: board[m.r][m.c],
        oldCR: { ...castlingRights }, oldEP: enPassantTarget,
        oldKP: { ...kingPos[p.color] }, oldHM: p.hasMoved, special: m, lastMoveBefore: lastMove
    };
    board[m.r][m.c] = p; board[fr][fc] = null; p.hasMoved = true;
    if (p.type === PIECES.KING) kingPos[p.color] = { r: m.r, c: m.c };
    if (m.isEnPassant) {
        const cr = p.color === COLORS.WHITE ? m.r + 1 : m.r - 1;
        undo.epCap = board[cr][m.c]; undo.epPos = { r: cr, c: m.c }; board[cr][m.c] = null;
    }
    if (m.castle) {
        const row = p.color === COLORS.WHITE ? 10 : 1;
        if (m.castle === 'K') { board[row][7] = board[row][10]; board[row][10] = null; }
        else { board[row][5] = board[row][1]; board[row][1] = null; }
    }
    if (p.type === PIECES.PAWN && ((p.color===COLORS.WHITE && m.r===1) || (p.color===COLORS.BLACK && m.r===10))) {
        p.type = PIECES.QUEEN; undo.prom = true;
    }
    enPassantTarget = (m.isDouble || m.isTriple) ? { r: m.r - (p.color === COLORS.WHITE ? -1 : 1), c: m.c } : null;
    if (p.type === PIECES.KING) { if(p.color===COLORS.WHITE){castlingRights.wK=false;castlingRights.wQ=false;}else{castlingRights.bK=false;castlingRights.bQ=false;} }
    if (pushToStack) undoStack.push(undo);
    return undo;
}

function undoMoveInternal(u) {
    board[u.fr][u.fc] = u.movedPiece; board[u.tr][u.tc] = u.captured;
    u.movedPiece.hasMoved = u.oldHM; if (u.prom) u.movedPiece.type = PIECES.PAWN;
    castlingRights = u.oldCR; enPassantTarget = u.oldEP; kingPos[u.movedPiece.color] = u.oldKP;
    if (u.epCap) board[u.epPos.r][u.epPos.c] = u.epCap;
    if (u.special.castle) {
        const row = u.movedPiece.color === COLORS.WHITE ? 10 : 1;
        if (u.special.castle === 'K') { board[row][10] = board[row][7]; board[row][7] = null; }
        else { board[row][1] = board[row][5]; board[row][5] = null; }
    }
    lastMove = u.lastMoveBefore;
}

function evaluate() {
    let s = 0;
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const p = board[r][c];
            if (p) {
                let v = PIECE_VALUES[p.type] + CENTER_BONUS[r][c];
                s += (p.color === COLORS.BLACK ? v : -v);
            }
        }
    }
    return s;
}

function minimax(d, a, b, isMax) {
    if (d === 0) return evaluate();
    const moves = getAllMoves(isMax ? COLORS.BLACK : COLORS.WHITE);
    if (moves.length === 0) return isInCheck(isMax ? COLORS.BLACK : COLORS.WHITE) ? (isMax ? -50000 : 50000) : 0;
    if (isMax) {
        let m = -Infinity;
        for (let move of moves) {
            const u = makeMoveInternal(move.fr, move.fc, move, false);
            m = Math.max(m, minimax(d - 1, a, b, false));
            undoMoveInternal(u); a = Math.max(a, m); if (b <= a) break;
        }
        return m;
    } else {
        let m = Infinity;
        for (let move of moves) {
            const u = makeMoveInternal(move.fr, move.fc, move, false);
            m = Math.min(m, minimax(d - 1, a, b, true));
            undoMoveInternal(u); b = Math.min(b, m); if (b <= a) break;
        }
        return m;
    }
}

function getAllMoves(col) {
    let mvs = [];
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            if (board[r][c] && board[r][c].color === col) {
                getMoves(r, c).forEach(m => mvs.push({ fr: r, fc: c, ...m }));
            }
        }
    }
    return mvs.sort((a, b) => (board[b.r][b.c] ? 1 : 0) - (board[a.r][a.c] ? 1 : 0));
}

function renderBoard() {
    const bEl = document.getElementById('board'); bEl.innerHTML = '';
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = document.createElement('div'); cell.className = 'square';
            if (!isValidSquare(r, c)) cell.classList.add('void');
            else if ((r===0 || r===11) && (c===0 || c===11)) cell.classList.add('wizard-square');
            else cell.classList.add((r+c)%2 ? 'dark' : 'light');
            if (selectedSq && selectedSq.r === r && selectedSq.c === c) cell.classList.add('selected');
            if (lastMove && ((lastMove.fr === r && lastMove.fc === c) || (lastMove.tr === r && lastMove.tc === c))) cell.classList.add('last-move');
            if (possibleMoves.some(m => m.r === r && m.c === c)) {
                const dot = document.createElement('div'); dot.className = 'hint-dot'; cell.appendChild(dot);
                cell.onclick = () => playerMove(r, c);
            } else if (!gameOver && board[r][c] && board[r][c].color === turn && turn === COLORS.WHITE) {
                cell.onclick = () => selectSquare(r, c);
            }
            if (board[r][c]) {
                const p = document.createElement('div'); p.className = `piece ${board[r][c].color === COLORS.WHITE ? 'white-piece' : 'black-piece'}`;
                p.innerText = SYMBOLS[board[r][c].type]; cell.appendChild(p);
            }
            bEl.appendChild(cell);
        }
    }
}

function selectSquare(r, c) { selectedSq = { r, c }; possibleMoves = getMoves(r, c); renderBoard(); }

function playerMove(r, c) {
    const m = possibleMoves.find(mv => mv.r === r && mv.c === c); if (!m) return;
    makeMoveInternal(selectedSq.r, selectedSq.c, m);
    lastMove = { fr: selectedSq.r, fc: selectedSq.c, tr: r, tc: c };
    selectedSq = null; possibleMoves = []; turn = COLORS.BLACK;
    renderBoard();
    if (!checkGameEnd(COLORS.BLACK)) {
        updateStatus("AI is thinking...");
        setTimeout(aiMove, 200);
    }
}

function aiMove() {
    const mvs = getAllMoves(COLORS.BLACK);
    if (mvs.length === 0) { checkGameEnd(COLORS.BLACK); return; }
    let best = null, maxS = -Infinity, a = -Infinity, b = Infinity;
    const depth = parseInt(document.getElementById('difficulty').value);
    for (let m of mvs) {
        const u = makeMoveInternal(m.fr, m.fc, m, false);
        const s = minimax(depth - 1, a, b, false);
        undoMoveInternal(u);
        if (s > maxS) { maxS = s; best = m; }
        a = Math.max(a, s);
    }
    if (best) {
        makeMoveInternal(best.fr, best.fc, best, true);
        lastMove = { fr: best.fr, fc: best.fc, tr: best.r, tc: best.c };
        turn = COLORS.WHITE; renderBoard();
        if (!checkGameEnd(COLORS.WHITE)) updateStatus(isInCheck(COLORS.WHITE) ? "Check! Your Turn" : "Your Turn");
    }
}

function undoMoveUI() {
    if (undoStack.length < 2 || turn !== COLORS.WHITE) return;
    undoMoveInternal(undoStack.pop()); // Undo AI
    undoMoveInternal(undoStack.pop()); // Undo Player
    gameOver = false; updateStatus("Your Turn"); renderBoard();
}

function checkGameEnd(col) {
    if (getAllMoves(col).length === 0) {
        updateStatus(isInCheck(col) ? (col === COLORS.WHITE ? "Checkmate! AI Wins!" : "Checkmate! You Win!") : "Stalemate!");
        gameOver = true; return true;
    }
    return false;
}

function updateStatus(msg) { document.getElementById('status').innerText = msg; }
function resetGame() { initBoard(); }
initBoard();
</script>
</body>
</html>






